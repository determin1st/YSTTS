// Generated by LiveScript 1.6.0
'use strict';
var YSTTS;
YSTTS = function(){
  var L00P, httpOption, httpFetch, Data, Api, Storage, proxy;
  L00P = function(){
    var jump, goto, api, Data, Routine, Api;
    jump = function(data, index, func){
      return function(){
        var R, I;
        if (data.started) {
          R = data.routine;
          I = data.index;
          if (index === R.length) {
            data.index = R[I].timeout = 0;
            data.started = R[I].active = false;
            data.paused = true;
            if (func) {
              func();
            }
          } else {
            R[I].timeout = 0;
            if (index !== I) {
              R[I].active = false;
              R[index].active = true;
              data.index = index;
            }
            data.paused = !func.call(R[index]);
          }
        }
      };
    };
    goto = function(routine, jump){
      return function(timeout){
        if (routine.active) {
          if (routine.timeout) {
            clearTimeout(routine.timeout);
            routine.timeout = 0;
          }
          if (timeout) {
            routine.timeout = setTimeout(jump, timeout);
          } else {
            jump();
          }
        }
      };
    };
    api = {
      get: function(data, k){
        switch (k) {
        case 'started':
        case 'paused':
          return data[k];
        }
        if (data.api[k]) {
          return data.api[k];
        }
        return null;
      },
      set: function(data, k, v){
        return true;
      }
    };
    Data = function(obj, onComplete){
      var a, c, b;
      this.started = false;
      this.paused = true;
      this.index = 0;
      this.routine = [];
      this.jump = [];
      this.api = new Api(this);
      a = Object.getOwnPropertyNames(obj);
      c = a.length;
      b = -1;
      while (++b < c) {
        this.jump[b] = jump(this, b, obj[a[b]]);
      }
      this.jump[c] = jump(this, c, onComplete);
      b = -1;
      while (++b < c) {
        this.routine[b] = new Routine(this, a, b);
      }
    };
    Routine = function(data, names, index){
      var a, b;
      this.active = false;
      this.timeout = 0;
      this.repeat = goto(this, data.jump[index]);
      this['continue'] = goto(this, data.jump[index + 1]);
      this['break'] = goto(this, data.jump[names.length]);
      a = -1;
      b = names.length;
      while (++a < b) {
        this[names[a]] = goto(this, data.jump[a]);
      }
    };
    Api = function(data){
      this.start = function(){
        if (!data.started) {
          data.started = data.routine[data.index].active = true;
          data.jump[data.index]();
        }
      };
      this.stop = function(){
        var R, I;
        if (data.started) {
          R = data.routine;
          I = data.index;
          if (!data.paused && R[I].timeout) {
            clearTimeout(R[I].timeout);
          }
          data.jump[R.length]();
        }
      };
      this.resume = function(){
        if (data.started && data.paused) {
          data.jump[data.index]();
        }
      };
    };
    return function(obj, onComplete){
      return new Proxy(new Data(obj, onComplete), api);
    };
  }();
  httpOption = function(){
    var Option;
    Option = function(){
      this.method = 'POST';
      this.body = '';
      this.signal = null;
      this.headers = {
        'Content-Type': 'application/json'
      };
    };
    return function(param){
      var o, a;
      o = new Option();
      if (param) {
        for (a in o) {
          if (param.hasOwnProperty(a)) {
            o[a] = param[a];
          }
        }
      }
      return o;
    };
  }();
  httpFetch = function(){
    var responseHandler;
    responseHandler = function(resp){
      return resp.json().then(function(resp){
        if (!resp.ok) {
          throw resp;
        }
        return resp;
      });
    };
    return function(timeout, url, opts, onComplete){
      var abrt;
      if (timeout) {
        abrt = new AbortController();
        opts.signal = abrt.signal;
        timeout = setTimeout(function(){
          abrt.abort();
        }, 1000 * timeout);
      } else {
        opts.signal = null;
      }
      return fetch(url, opts).then(responseHandler).then(function(r){
        if (timeout) {
          clearTimeout(timeout);
        }
        onComplete(true, r);
      })['catch'](function(e){
        onComplete(false, e);
      });
    };
  }();
  Data = function(opts){
    var c, i$, len$, a;
    this.url = 'https://api.telegram.org/bot' + opts.token + '/';
    this.chat_id = opts.chat_id;
    this.username = opts.username || '';
    this.bot = null;
    this.chat = null;
    this.ready = false;
    this.pusher = null;
    this.puller = null;
    this.error = '';
    this.active = 0;
    this.timeout = 0;
    this.queue = [];
    this.index = 0;
    this.api = new Api(this);
    this.storage = new Storage(this);
    c = ['onStart', 'onStop', 'onError', 'onUpdate'];
    for (i$ = 0, len$ = c.length; i$ < len$; ++i$) {
      a = c[i$];
      if (opts.hasOwnProperty(a)) {
        if (typeof opts[a] === 'function') {
          this[a] = opts[a];
        }
      }
    }
  };
  Api = function(data){
    this.start = function(){
      if (!data.ready && !data.puller.started) {
        data.puller.start();
      }
    };
    this.stop = function(){
      if (data.ready) {
        data.puller.stop();
      }
    };
    this.sendMessage = function(text){
      if (!data.pusher.started || !text) {
        return false;
      }
      text = JSON.stringify({
        chat_id: data.chat_id,
        text: '*' + data.username + '*`:` ' + text,
        parse_mode: 'Markdown'
      });
      data.queue.push(['sendMessage', text, 1]);
      data.pusher.resume();
      return true;
    };
    this.sendLog = function(text){
      if (!data.pusher.started || !text) {
        return false;
      }
      text = JSON.stringify({
        chat_id: data.chat_id,
        text: '`log:`*' + data.username + '*`:` ' + text,
        parse_mode: 'Markdown',
        disable_notification: true
      });
      data.queue.push(['sendMessage', text, 2]);
      data.pusher.resume();
      return true;
    };
    this.sendTypingAction = function(){
      var text;
      if (!data.pusher.started) {
        return false;
      }
      text = JSON.stringify({
        chat_id: data.chat_id,
        action: 'typing'
      });
      data.queue.push(['sendChatAction', text, 0]);
      data.pusher.resume();
      return true;
    };
  };
  Storage = function(){
    var Message, Store;
    Message = function(id){
      this.id = id;
      this.self = false;
      this.date = 0;
      this.text = '';
    };
    Store = function(data){
      this.data = data;
      this.last_id = 0;
      this.heap = {};
      this.list = [];
    };
    Store.prototype = {
      init: function(onComplete){
        onComplete(true);
      },
      output: function(type, v){
        var a, ref$, b;
        if (!type) {
          return false;
        }
        if (type !== 1) {
          this.heap[v.message_id] = false;
          return false;
        }
        a = (ref$ = this.list)[ref$.length] = v.message_id;
        b = this.heap[a] = new Message(a);
        b.self = true;
        b.date = v.date;
        b.text = v.text.substring(2 + v.text.indexOf(':'));
        return true;
      },
      input: function(v){
        var i, list, heap, c, a, b;
        if (!(i = v.length)) {
          return false;
        }
        list = this.list, heap = this.heap;
        c = 0;
        while (--i >= 0) {
          if (v[i].update_id === this.last_id) {
            break;
          }
          a = v[i].message;
          b = a.reply_to_message;
          if (b && heap.hasOwnProperty(b.message_id)) {
            b = list[list.length] = a.message_id;
            b = heap[b] = new Message(b);
            b.date = a.date;
            b.text = a.text;
            ++c;
          }
        }
        this.last_id = v[v.length - 1].update_id;
        if (c) {
          list.sort(function(a, b){
            a = heap[a].date;
            b = heap[b].date;
            return a < b
              ? -1
              : a === b ? 0 : 1;
          });
        }
        return c;
      },
      get: function(){
        var this$ = this;
        return this.list.map(function(id){
          return this$.heap[id];
        });
      }
    };
    return Store;
  }();
  proxy = function(){
    var timeouts;
    timeouts = [0, 60000, 40000, 20000, 10000];
    return {
      get: function(data, k){
        switch (k) {
        case 'ready':
        case 'active':
        case 'error':
          return data[k];
        case 'data':
          return data.ready ? data.storage.get() : null;
        case 'chatname':
          return data.ready ? data.chat.first_name : '';
        case 'username':
          return data.username;
        }
        if (data.api.hasOwnProperty(k)) {
          return data.api[k];
        }
        return null;
      },
      set: function(data, k, v){
        switch (k) {
        case 'active':
          if (!data.ready || !data.onUpdate) {
            break;
          }
          if ((v = parseInt(v)) < 0) {
            break;
          }
          if (v >= timeouts.length) {
            v = timeouts.length - 1;
          }
          data.active = v;
          data.timeout = timeouts[v];
          if (data.puller.paused) {
            data.puller.resume();
          }
        }
        return true;
      }
    };
  }();
  return function(opts){
    var o1, o2, data, api;
    o1 = httpOption();
    o2 = httpOption();
    data = new Data(opts);
    api = new Proxy(data, proxy);
    data.pusher = L00P({
      push: function(){
        var c, task, this$ = this;
        if (!(c = data.queue.length)) {
          return false;
        }
        task = data.queue[data.index];
        o1.body = task[1];
        httpFetch(5, data.url + task[0], o1, function(ok, res){
          if (ok) {
            if (++data.index === c) {
              data.index = data.queue.length = 0;
            }
            if (data.storage.output(task[2], res.result)) {
              if (data.onUpdate) {
                data.onUpdate.call(api, 1);
              }
            }
            this$.repeat(200);
          } else {
            data.error = 'failed to push';
            if (res.description) {
              data.error += ': ' + res.description;
            } else if (res.code === 20) {
              data.error += ': connection timeout';
            }
            if (data.onError) {
              data.onError.call(api, res);
            }
            this$['break']();
          }
        });
        return true;
      }
    });
    data.puller = L00P({
      checkBot: function(){
        var this$ = this;
        httpFetch(5, data.url + 'getMe', o2, function(ok, res){
          if (ok) {
            data.bot = res.result;
            this$['continue']();
          } else {
            data.error = 'failed to check bot';
            if (res.description) {
              data.error += ': ' + res.description;
            } else if (res.code === 20) {
              data.error += ': connection timeout';
            }
            this$['break']();
          }
        });
        return true;
      },
      checkChat: function(){
        var this$ = this;
        o2.body = JSON.stringify({
          chat_id: data.chat_id
        });
        httpFetch(5, data.url + 'getChat', o2, function(ok, res){
          if (ok) {
            data.chat = res.result;
            this$['continue']();
          } else {
            data.error = 'failed to check bot';
            if (res.description) {
              data.error += ': ' + res.description;
            } else if (res.code === 20) {
              data.error += ': connection timeout';
            }
            this$['break']();
          }
        });
        return true;
      },
      startChat: function(){
        var this$ = this;
        data.pusher.start();
        data.storage.init(function(ok, res){
          if (data.ready = ok) {
            if (data.onStart) {
              data.onStart.call(api);
            }
            this$['continue']();
          } else {
            data.error = 'failed to initialize data storage';
            this$['break']();
          }
        });
        return true;
      },
      pull: function(){
        var this$ = this;
        if (!data.timeout) {
          return false;
        }
        o2.body = JSON.stringify({
          offset: -100
        });
        httpFetch(10, data.url + 'getUpdates', o2, function(ok, res){
          if (ok) {
            if (data.storage.input(res.result)) {
              if (data.onUpdate) {
                data.onUpdate.call(api);
              }
            }
          } else {
            data.error = 'failed to check bot';
            if (res.description) {
              data.error += ': ' + res.description;
            } else if (res.code === 20) {
              data.error += ': connection timeout';
            }
            if (data.onError) {
              data.onError.call(api, res);
            }
          }
          this$.repeat(data.timeout);
        });
        return true;
      }
    }, function(){
      data.ready = false;
      data.active = data.timeout = 0;
      data.pusher.stop();
      if (data.onStop) {
        data.onStop.call(api);
      }
    });
    return api;
  };
}();